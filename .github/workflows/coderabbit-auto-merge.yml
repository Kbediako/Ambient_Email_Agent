name: Enable auto-merge after CodeRabbit approval

on:
  pull_request_review:
    types: [submitted]

permissions:
  contents: write
  pull-requests: write

jobs:
  enable-auto-merge:
    if: contains(fromJson('["coderabbitai","coderabbitai[bot]","coderabbit","coderabbit[bot]","CodeRabbit","CodeRabbit[bot]"]'), github.event.review.user.login) && github.event.review.state == 'approved'
    runs-on: ubuntu-latest
    steps:
      - name: Enable GitHub auto-merge
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            if (pr.draft) {
              core.info("PR is draft; skipping auto-merge enablement.");
              return;
            }
            if (pr.state !== "open") {
              core.info(`PR state is ${pr.state}; skipping auto-merge enablement.`);
              return;
            }

            const { owner, repo } = context.repo;

            // Fetch live mergeability to avoid enabling auto-merge while GitHub marks
            // the PR as "unstable" (e.g., required checks still running/failing).
            const fetchMergeability = async () => {
              return github.rest.pulls.get({ owner, repo, pull_number: pr.number });
            };

            let prDetails;
            try {
              prDetails = await fetchMergeability();
            } catch (error) {
              const message = error.errors?.map(e => e.message).join('; ') || error.message;
              core.warning(`Unable to fetch pull request mergeability: ${message}. Will retry on the next approval event.`);
              return;
            }

            let mergeableState = prDetails.data.mergeable_state;
            let mergeableFlag = prDetails.data.mergeable;
            const retryDelayMs = Number(process.env.AUTO_MERGE_MERGEABLE_DELAY_MS || 3000);
            const maxRetries = Number(process.env.AUTO_MERGE_MERGEABLE_RETRIES || 3);

            for (let attempt = 1; mergeableFlag === null && attempt <= maxRetries; attempt += 1) {
              core.info(`mergeability still computing (state=${mergeableState}); retry ${attempt}/${maxRetries} after ${retryDelayMs}ms.`);
              await new Promise((resolve) => setTimeout(resolve, retryDelayMs));
              try {
                prDetails = await fetchMergeability();
              } catch (error) {
                const message = error.errors?.map(e => e.message).join('; ') || error.message;
                core.warning(`Retry ${attempt} failed to fetch mergeability: ${message}. Will retry on the next approval event.`);
                return;
              }
              mergeableState = prDetails.data.mergeable_state;
              mergeableFlag = prDetails.data.mergeable;
            }

            const allowedStates = ["clean", "has_hooks", "stable", "behind"];
            const transientStates = (process.env.AUTO_MERGE_TRANSIENT_STATES || "unstable")
              .split(",")
              .map((state) => state.trim())
              .filter(Boolean);

            const shouldRetryState = () => transientStates.includes(mergeableState);
            for (let attempt = 1; !allowedStates.includes(mergeableState) && shouldRetryState() && attempt <= maxRetries; attempt += 1) {
              core.info(
                `mergeable_state=${mergeableState} not yet allowed; retry ${attempt}/${maxRetries} after ${retryDelayMs}ms.`
              );
              await new Promise((resolve) => setTimeout(resolve, retryDelayMs));
              try {
                prDetails = await fetchMergeability();
              } catch (error) {
                const message = error.errors?.map((e) => e.message).join('; ') || error.message;
                core.warning(`Retry ${attempt} failed to fetch mergeability: ${message}. Will retry on the next approval event.`);
                return;
              }
              mergeableState = prDetails.data.mergeable_state;
              mergeableFlag = prDetails.data.mergeable;
            }

            if (mergeableFlag === null) {
              core.warning(`PR mergeable_state=${mergeableState} mergeable=null after ${maxRetries} retries; mergeability still computing. Will retry later.`);
              return;
            }
            const isAllowedState = allowedStates.includes(mergeableState);
            const isTransientButMergeable = transientStates.includes(mergeableState) && mergeableFlag === true;
            if (!isAllowedState && !isTransientButMergeable) {
              core.warning(
                `PR mergeable_state=${mergeableState} mergeable=${mergeableFlag}; skipping auto-merge enablement until GitHub reports a stable state.`
              );
              return;
            }
            if (isTransientButMergeable) {
              core.info(`mergeable_state=${mergeableState} reported with mergeable=true; proceeding with auto-merge enablement.`);
            }
            if (mergeableFlag === false && !["has_hooks", "behind"].includes(mergeableState)) {
              core.warning(`PR mergeable_state=${mergeableState} mergeable=${mergeableFlag}; skipping auto-merge enablement until GitHub reports a stable state.`);
              return;
            }

            const query = `mutation($prId: ID!, $mergeMethod: PullRequestMergeMethod!) {
              enablePullRequestAutoMerge(input: { pullRequestId: $prId, mergeMethod: $mergeMethod }) {
                pullRequest {
                  number
                  autoMergeRequest {
                    enabledAt
                    enabledBy { login }
                  }
                }
              }
            }`;

            try {
              const rawMethod = (process.env.AUTO_MERGE_METHOD || "SQUASH").trim().toUpperCase();
              const aliases = { MERGE_COMMIT: "MERGE", REBASE_MERGE: "REBASE", SQUASH_MERGE: "SQUASH" };
              let mergeMethod = aliases[rawMethod] || rawMethod;
              const allowed = ["MERGE", "SQUASH", "REBASE"];
              if (!allowed.includes(mergeMethod)) {
                core.warning(`Invalid AUTO_MERGE_METHOD "${mergeMethod}", defaulting to SQUASH.`);
                mergeMethod = "SQUASH";
              }
              core.info(`Attempting to enable auto-merge with method: ${mergeMethod}`);
              const enable = async (method) => github.graphql(query, { prId: pr.node_id, mergeMethod: method });
              let result;
              try {
                result = await enable(mergeMethod);
              } catch (error) {
                const message = error.errors?.map(e => e.message).join('; ') || error.message;
                if (mergeMethod !== "SQUASH" && /not (allowed|enabled)|disabled/i.test(message)) {
                  core.warning(`Merge method "${mergeMethod}" not permitted; falling back to SQUASH.`);
                  result = await enable("SQUASH");
                } else {
                  throw error;
                }
              }
              const enabledBy = result?.enablePullRequestAutoMerge?.pullRequest?.autoMergeRequest?.enabledBy?.login;
              core.info(`Auto-merge enabled by ${enabledBy || 'workflow'} for PR #${pr.number}.`);
            } catch (error) {
              const message = error.errors?.map(e => e.message).join('; ') || error.message;
              if (message.match(/already enabled|mergeable|Cannot enable auto-merge/i)) {
                core.warning(`Skipping auto-merge enablement: ${message}`);
                return;
              }
              throw error;
            }
