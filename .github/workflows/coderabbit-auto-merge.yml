name: Enable auto-merge after CodeRabbit approval

on:
  pull_request_review:
    types: [submitted]
  workflow_dispatch:
    inputs:
      pull_request:
        description: "PR number to enable auto-merge for"
        required: true
        type: string

permissions:
  contents: write
  pull-requests: write

jobs:
  enable-auto-merge:
    if: >-
      (github.event_name == 'pull_request_review'
        && contains(fromJson('["coderabbitai","coderabbitai[bot]","coderabbit","coderabbit[bot]","CodeRabbit","CodeRabbit[bot]"]'), github.event.review.user.login)
        && github.event.review.state == 'approved')
      || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - name: Enable GitHub auto-merge
        uses: actions/github-script@v7
        env:
          DISPATCH_PR_NUMBER: ${{ github.event.inputs.pull_request }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const dispatchInput = github?.event?.inputs?.pull_request;
            const envDispatch = process.env.DISPATCH_PR_NUMBER;
            const envInput = process.env.INPUT_PULL_REQUEST;
            const inputPrNumber = core.getInput ? core.getInput('pull_request') : undefined;
            const prNumberRaw = pr?.number ?? dispatchInput ?? inputPrNumber ?? envInput ?? envDispatch;
            const prNumber = prNumberRaw ? Number(prNumberRaw) : undefined;
            core.info(`Resolved prNumberRaw=${prNumberRaw ?? 'undefined'} prNumber=${prNumber ?? 'undefined'}`);
            if (!prNumber || Number.isNaN(prNumber)) {
              core.setFailed('No pull request number available; provide `pull_request` input when dispatching manually.');
              return;
            }

            const { owner, repo } = context.repo;

            const fetchLivePr = async () => {
              return github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            };

            let prSnapshot = pr;
            if (!prSnapshot) {
              core.info(`Fetching PR #${prNumber} details for manual dispatch.`);
              try {
                const response = await fetchLivePr();
                prSnapshot = response.data;
              } catch (error) {
                const message = error.errors?.map(e => e.message).join('; ') || error.message;
                core.setFailed(`Unable to fetch PR #${prNumber}: ${message}`);
                return;
              }
            }

            if (prSnapshot.draft) {
              core.info("PR is draft; skipping auto-merge enablement.");
              return;
            }
            if (prSnapshot.state !== "open") {
              core.info(`PR state is ${prSnapshot.state}; skipping auto-merge enablement.`);
              return;
            }

            // Fetch live mergeability to avoid enabling auto-merge while GitHub marks
            // the PR as "unstable" (e.g., required checks still running/failing).
            const fetchMergeability = async () => {
              return github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            };

            let prDetails;
            try {
              prDetails = await fetchMergeability();
            } catch (error) {
              const message = error.errors?.map(e => e.message).join('; ') || error.message;
              core.warning(`Unable to fetch pull request mergeability: ${message}. Will retry on the next approval event.`);
              return;
            }

            let mergeableState = prDetails.data.mergeable_state;
            let mergeableFlag = prDetails.data.mergeable;
            const retryDelayMs = Number(process.env.AUTO_MERGE_MERGEABLE_DELAY_MS || 5000);
            const maxRetries = Number(process.env.AUTO_MERGE_MERGEABLE_RETRIES || 6);

            for (let attempt = 1; mergeableFlag === null && attempt <= maxRetries; attempt += 1) {
              core.info(`mergeability still computing (state=${mergeableState}); retry ${attempt}/${maxRetries} after ${retryDelayMs}ms.`);
              await new Promise((resolve) => setTimeout(resolve, retryDelayMs));
              try {
                prDetails = await fetchMergeability();
              } catch (error) {
                const message = error.errors?.map(e => e.message).join('; ') || error.message;
                core.warning(`Retry ${attempt} failed to fetch mergeability: ${message}. Will retry on the next approval event.`);
                return;
              }
              mergeableState = prDetails.data.mergeable_state;
              mergeableFlag = prDetails.data.mergeable;
            }

            const allowedStates = ["clean", "has_hooks", "stable", "behind"];
            const transientStates = (process.env.AUTO_MERGE_TRANSIENT_STATES || "unstable")
              .split(",")
              .map((state) => state.trim())
              .filter(Boolean);

            const shouldRetryState = () => transientStates.includes(mergeableState);
            for (let attempt = 1; !allowedStates.includes(mergeableState) && shouldRetryState() && attempt <= maxRetries; attempt += 1) {
              core.info(
                `mergeable_state=${mergeableState} not yet allowed; retry ${attempt}/${maxRetries} after ${retryDelayMs}ms.`
              );
              await new Promise((resolve) => setTimeout(resolve, retryDelayMs));
              try {
                prDetails = await fetchMergeability();
              } catch (error) {
                const message = error.errors?.map((e) => e.message).join('; ') || error.message;
                core.warning(`Retry ${attempt} failed to fetch mergeability: ${message}. Will retry on the next approval event.`);
                return;
              }
              mergeableState = prDetails.data.mergeable_state;
              mergeableFlag = prDetails.data.mergeable;
            }

            if (mergeableFlag === null) {
              core.warning(`PR mergeable_state=${mergeableState} mergeable=null after ${maxRetries} retries; mergeability still computing. Will retry later.`);
              return;
            }
            const isAllowedState = allowedStates.includes(mergeableState);
            const isTransientState = transientStates.includes(mergeableState);
            if (!isAllowedState) {
              if (isTransientState) {
                core.setFailed(
                  `PR mergeable_state=${mergeableState} still transient after ${maxRetries} retries; rerun once GitHub marks it clean.`
                );
              } else {
                core.warning(
                  `PR mergeable_state=${mergeableState} mergeable=${mergeableFlag}; skipping auto-merge enablement until GitHub reports a stable state.`
                );
              }
              return;
            }
            if (mergeableFlag === false && !["has_hooks", "behind"].includes(mergeableState)) {
              core.warning(`PR mergeable_state=${mergeableState} mergeable=${mergeableFlag}; skipping auto-merge enablement until GitHub reports a stable state.`);
              return;
            }

            const query = `mutation($prId: ID!, $mergeMethod: PullRequestMergeMethod!) {
              enablePullRequestAutoMerge(input: { pullRequestId: $prId, mergeMethod: $mergeMethod }) {
                pullRequest {
                  number
                  autoMergeRequest {
                    enabledAt
                    enabledBy { login }
                  }
                }
              }
            }`;

            try {
              const rawMethod = (process.env.AUTO_MERGE_METHOD || "SQUASH").trim().toUpperCase();
              const aliases = { MERGE_COMMIT: "MERGE", REBASE_MERGE: "REBASE", SQUASH_MERGE: "SQUASH" };
              let mergeMethod = aliases[rawMethod] || rawMethod;
              const allowed = ["MERGE", "SQUASH", "REBASE"];
              if (!allowed.includes(mergeMethod)) {
                core.warning(`Invalid AUTO_MERGE_METHOD "${mergeMethod}", defaulting to SQUASH.`);
                mergeMethod = "SQUASH";
              }
              core.info(`Attempting to enable auto-merge with method: ${mergeMethod}`);
              const prNodeId = pr?.node_id ?? prSnapshot.node_id;
              const enable = async (method) => github.graphql(query, { prId: prNodeId, mergeMethod: method });
              let result;
              try {
                result = await enable(mergeMethod);
              } catch (error) {
                const message = error.errors?.map(e => e.message).join('; ') || error.message;
                if (mergeMethod !== "SQUASH" && /not (allowed|enabled)|disabled/i.test(message)) {
                  core.warning(`Merge method "${mergeMethod}" not permitted; falling back to SQUASH.`);
                  result = await enable("SQUASH");
                } else {
                  throw error;
                }
              }
              const enabledBy = result?.enablePullRequestAutoMerge?.pullRequest?.autoMergeRequest?.enabledBy?.login;
              core.info(`Auto-merge enabled by ${enabledBy || 'workflow'} for PR #${prNumber}.`);
            } catch (error) {
              const message = error.errors?.map(e => e.message).join('; ') || error.message;
              if (message.match(/already enabled|mergeable|Cannot enable auto-merge/i)) {
                core.warning(`Skipping auto-merge enablement: ${message}`);
                return;
              }
              throw error;
            }
