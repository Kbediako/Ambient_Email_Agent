name: Enable auto-merge after CodeRabbit approval

on:
  pull_request_review:
    types: [submitted]

permissions:
  contents: write
  pull-requests: write

jobs:
  enable-auto-merge:
    if: contains(fromJson('["coderabbitai","coderabbitai[bot]"]'), github.event.review.user.login) && github.event.review.state == 'approved'
    runs-on: ubuntu-latest
    steps:
      - name: Enable GitHub auto-merge
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            if (pr.draft) {
              core.info("PR is draft; skipping auto-merge enablement.");
              return;
            }
            if (pr.state !== "open") {
              core.info(`PR state is ${pr.state}; skipping auto-merge enablement.`);
              return;
            }

            const { owner, repo } = context.repo;

            // Fetch live mergeability to avoid enabling auto-merge while GitHub marks
            // the PR as "unstable" (e.g., required checks still running/failing).
            let prDetails;
            try {
              prDetails = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: pr.number,
              });
            } catch (error) {
              const message = error.errors?.map(e => e.message).join('; ') || error.message;
              core.warning(`Unable to fetch pull request mergeability: ${message}. Will retry on the next approval event.`);
              return;
            }
            const mergeableState = prDetails.data.mergeable_state;
            const mergeableFlag = prDetails.data.mergeable;
            const allowedStates = ["clean", "has_hooks", "stable"];
            if (!allowedStates.includes(mergeableState)) {
              core.warning(`PR mergeable_state=${mergeableState} mergeable=${mergeableFlag}; skipping auto-merge enablement until GitHub reports a stable state.`);
              return;
            }
            if (mergeableFlag === null) {
              core.warning(`PR mergeable_state=${mergeableState} mergeable=null; mergeability still computing. Will retry later.`);
              return;
            }
            if (mergeableFlag === false && mergeableState !== "has_hooks") {
              core.warning(`PR mergeable_state=${mergeableState} mergeable=${mergeableFlag}; skipping auto-merge enablement until GitHub reports a stable state.`);
              return;
            }

            const query = `mutation($prId: ID!, $mergeMethod: PullRequestMergeMethod!) {
              enablePullRequestAutoMerge(input: { pullRequestId: $prId, mergeMethod: $mergeMethod }) {
                pullRequest {
                  number
                  autoMergeRequest {
                    enabledAt
                    enabledBy { login }
                  }
                }
              }
            }`;

            try {
              const rawMethod = (process.env.AUTO_MERGE_METHOD || "SQUASH").trim().toUpperCase();
              const aliases = { MERGE_COMMIT: "MERGE", REBASE_MERGE: "REBASE", SQUASH_MERGE: "SQUASH" };
              let mergeMethod = aliases[rawMethod] || rawMethod;
              const allowed = ["MERGE", "SQUASH", "REBASE"];
              if (!allowed.includes(mergeMethod)) {
                core.warning(`Invalid AUTO_MERGE_METHOD "${mergeMethod}", defaulting to SQUASH.`);
                mergeMethod = "SQUASH";
              }
              core.info(`Attempting to enable auto-merge with method: ${mergeMethod}`);
              const enable = async (method) => github.graphql(query, { prId: pr.node_id, mergeMethod: method });
              let result;
              try {
                result = await enable(mergeMethod);
              } catch (error) {
                const message = error.errors?.map(e => e.message).join('; ') || error.message;
                if (mergeMethod !== "SQUASH" && /not (allowed|enabled)|disabled/i.test(message)) {
                  core.warning(`Merge method "${mergeMethod}" not permitted; falling back to SQUASH.`);
                  result = await enable("SQUASH");
                } else {
                  throw error;
                }
              }
              const enabledBy = result?.enablePullRequestAutoMerge?.pullRequest?.autoMergeRequest?.enabledBy?.login;
              core.info(`Auto-merge enabled by ${enabledBy || 'workflow'} for PR #${pr.number}.`);
            } catch (error) {
              const message = error.errors?.map(e => e.message).join('; ') || error.message;
              if (message.match(/already enabled|mergeable|Cannot enable auto-merge/i)) {
                core.warning(`Skipping auto-merge enablement: ${message}`);
                return;
              }
              throw error;
            }
